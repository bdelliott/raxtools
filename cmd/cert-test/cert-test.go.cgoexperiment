package main

/*
#cgo CFLAGS: -mmacosx-version-min=10.6 -D__MAC_OS_X_VERSION_MAX_ALLOWED=1080
#cgo LDFLAGS: -framework CoreFoundation -framework Security

#include <stdio.h>
#include <stdlib.h>
#include <errno.h>
#include <sys/sysctl.h>

#include <CoreFoundation/CoreFoundation.h>
#include <Security/Security.h>

// FetchPEMRoots fetches the system's list of trusted X.509 root certificates.
//
// On success it returns 0 and fills pemRoots with a CFDataRef that contains the extracted root
// certificates of the system. On failure, the function returns -1.
// Additionally, it fills untrustedPemRoots with certs that must be removed from pemRoots.
//
// Note: The CFDataRef returned in pemRoots and untrustedPemRoots must
// be released (using CFRelease) after we've consumed its content.
int FetchPEMRootz(CFDataRef *pemRoots, CFDataRef *untrustedPemRoots) {

	// Get certificates from all domains, not just System, this lets
	// the user add CAs to their "login" keychain, and Admins to add
	// to the "System" keychain
	SecTrustSettingsDomain domains[] = { kSecTrustSettingsDomainSystem,
					     kSecTrustSettingsDomainAdmin,
					     kSecTrustSettingsDomainUser };

	int numDomains = sizeof(domains)/sizeof(SecTrustSettingsDomain);
	if (pemRoots == NULL) {
		return -1;
	}

	printf("print");

	FILE *f = fopen("/Users/bria4812/cgo_dbg.log", "w");
	fprintf(f, "Start:\n");

	// kSecTrustSettingsResult is defined as CFSTR("kSecTrustSettingsResult"),
	// but the Go linker's internal linking mode can't handle CFSTR relocations.
	// Create our own dynamic string instead and release it below.
	CFStringRef policy = CFStringCreateWithCString(NULL, "kSecTrustSettingsResult", kCFStringEncodingUTF8);

	CFMutableDataRef combinedData = CFDataCreateMutable(kCFAllocatorDefault, 0);
	CFMutableDataRef combinedUntrustedData = CFDataCreateMutable(kCFAllocatorDefault, 0);
	for (int i = 0; i < numDomains; i++) {

		fprintf(f, "--------------\n");
		fprintf(f, "Domain start %d:\n", domains[i]);
		fprintf(f, "--------------\n");

		fprintf(f, "Default domain trust policy:\n");
		CFArrayRef defaultDomainTrustSettings = NULL;
		OSStatus err2 = SecTrustSettingsCopyTrustSettings( kSecTrustSettingsDefaultRootCertSetting , domains[i], &defaultDomainTrustSettings);
		fprintf(f, "err2 = %d\n", err2);

		if (err2 == errSecItemNotFound) {
			fprintf(f, "errSecItemNotFound\n");
		}

		if (defaultDomainTrustSettings) {
			CFRelease(defaultDomainTrustSettings);
		}

		CFArrayRef certs = NULL;
		OSStatus err = SecTrustSettingsCopyCertificates(domains[i], &certs);
		if (err != noErr) {
			continue;
		}

		CFIndex numCerts = CFArrayGetCount(certs);
		for (int j = 0; j < numCerts; j++) {
			fprintf(f, "j=%d\n", j);
			CFDataRef data = NULL;
			CFErrorRef errRef = NULL;
			CFArrayRef trustSettings = NULL;
			SecCertificateRef cert = (SecCertificateRef)CFArrayGetValueAtIndex(certs, j);
			if (cert == NULL) {
				continue;
			}
			// We only want trusted certs.
			int untrusted = 0;
			int trustAsRoot = 0;
			int trustRoot = 0;
			if (i == 0) {
				trustAsRoot = 1;
			} else {
				// Certs found in the system domain are always trusted. If the user
				// configures "Never Trust" on such a cert, it will also be found in the
				// admin or user domain, causing it to be added to untrustedPemRoots. The
				// Go code will then clean this up.

				// Trust may be stored in any of the domains. According to Apple's
				// SecTrustServer.c, "user trust settings overrule admin trust settings",
				// so take the last trust settings array we find.
				// Skip the system domain since it is always trusted.
				for (int k = i; k < numDomains; k++) {
					CFArrayRef domainTrustSettings = NULL;
					err = SecTrustSettingsCopyTrustSettings(cert, domains[k], &domainTrustSettings);
					if (err == errSecSuccess && domainTrustSettings != NULL) {
						fprintf(f, "Got trust settings\n");
						if (trustSettings) {
							CFRelease(trustSettings);
						}
						trustSettings = domainTrustSettings;
					}
				}
				if (trustSettings == NULL) {
					// "this certificate must be verified to a known trusted certificate"; aka not a root.
					continue;
				}
				fprintf(f, "Number of trust settings for cert %d is %ld\n", j, CFArrayGetCount(trustSettings));
				for (CFIndex k = 0; k < CFArrayGetCount(trustSettings); k++) {
					//fprintf(f, "  k=%d\n", k);
					CFNumberRef cfNum;
					CFDictionaryRef tSetting = (CFDictionaryRef)CFArrayGetValueAtIndex(trustSettings, k);
					if (CFDictionaryGetValueIfPresent(tSetting, policy, (const void**)&cfNum)){
						SInt32 result = 0;
						CFNumberGetValue(cfNum, kCFNumberSInt32Type, &result);
						// TODO: The rest of the dictionary specifies conditions for evaluation.
						if (result == kSecTrustSettingsResultDeny) {
							fprintf(f, "kSecTrustSettingsResultDeny\n");
							untrusted = 1;
						} else if (result == kSecTrustSettingsResultTrustAsRoot) {
							trustAsRoot = 1;
							//fprintf(f, "kSecTrustSettingsResultTrustAsRoot\n");
						} else if (result == kSecTrustSettingsResultTrustRoot) {
							trustRoot = 1;
							//fprintf(f, "kSecTrustSettingsResultTrustRoot\n");
						} else {
							fprintf(f, "default case, result=%d\n", result);
						}
					}
				}
				CFRelease(trustSettings);
			}

			if (trustRoot) {
				// We only want to add Root CAs, so make sure Subject and Issuer Name match
				CFDataRef subjectName = SecCertificateCopyNormalizedSubjectContent(cert, &errRef);
				if (errRef != NULL) {
					CFRelease(errRef);
					continue;
				}
				CFDataRef issuerName = SecCertificateCopyNormalizedIssuerContent(cert, &errRef);
				if (errRef != NULL) {
					CFRelease(subjectName);
					CFRelease(errRef);
					continue;
				}
				Boolean equal = CFEqual(subjectName, issuerName);
				CFRelease(subjectName);
				CFRelease(issuerName);
				if (!equal) {
					continue;
				}
			}

			// Note: SecKeychainItemExport is deprecated as of 10.7 in favor of SecItemExport.
			// Once we support weak imports via cgo we should prefer that, and fall back to this
			// for older systems.
			err = SecKeychainItemExport(cert, kSecFormatX509Cert, kSecItemPemArmour, NULL, &data);
			if (err != noErr) {
				continue;
			}

			if (data != NULL) {
				if (!trustRoot && !trustAsRoot) {
					fprintf(f, "untrusted\n");
					untrusted = 1;
				}

				CFMutableDataRef appendTo = untrusted ? combinedUntrustedData : combinedData;
				CFDataAppendBytes(appendTo, CFDataGetBytePtr(data), CFDataGetLength(data));
				CFRelease(data);
			}
		}
		CFRelease(certs);
	}
	CFRelease(policy);
	*pemRoots = combinedData;
	*untrustedPemRoots = combinedUntrustedData;

	fflush(f);
	fclose(f);

	return 0;
}
 */
import "C"
import (
	"crypto/x509"
	"errors"
	"unsafe"
)


// experiment with certificate management related code libs in Go:
func main() {

	loadSystemRoots()
	/*certPool, err := x509.SystemCertPool()
	if err != nil {
		panic(err)
	}
	rawSubjects := certPool.Subjects()


	fmt.Println(len(rawSubjects))

	// return list of byte slices containing DER encoding raw subjects

	for _, rawSubject := range rawSubjects {

		var rdnSubject pkix.RDNSequence

		_, err := asn1.Unmarshal(rawSubject, &rdnSubject)
		if err != nil {
			panic(err)
		}
		name := pkix.Name{}
		name.FillFromRDNSequence(&rdnSubject)

		//fmt.Println(name.SerialNumber)
		//fmt.Println(name.CommonName)

		commonName := strings.ToLower(name.CommonName)
		if strings.Contains(commonName, "kube") {
			fmt.Println("woot")
			fmt.Println(name)
		}
	}
	}

	for _, rawSubject:= range rawSubjects {

		var rdnSubject pkix.RDNSequence
		_, err := asn1.Unmarshal(rawSubject, &rdnSubject)
		if err != nil {
			panic(err)
		}

		for _, foo := range rdnSubject {
			for _, bar := range foo {
				lbar := strings.ToLower(bar.Value.(string))
				if strings.Contains(lbar, "kube") {
					fmt.Println("woot")
					fmt.Println(lbar)
				}
			}
		}


	}*/
}


func loadSystemRoots() (*x509.CertPool, error) {
	roots := x509.NewCertPool()

	var data C.CFDataRef = 0
	var untrustedData C.CFDataRef = 0
	err := C.FetchPEMRootz(&data, &untrustedData)
	if err == -1 {
		// TODO: better error message
		return nil, errors.New("crypto/x509: failed to load darwin system roots with cgo")
	}

	defer C.CFRelease(C.CFTypeRef(data))
	buf := C.GoBytes(unsafe.Pointer(C.CFDataGetBytePtr(data)), C.int(C.CFDataGetLength(data)))
	roots.AppendCertsFromPEM(buf)
	if untrustedData == 0 {
		return roots, nil
	}
	defer C.CFRelease(C.CFTypeRef(untrustedData))
	buf = C.GoBytes(unsafe.Pointer(C.CFDataGetBytePtr(untrustedData)), C.int(C.CFDataGetLength(untrustedData)))
	untrustedRoots := x509.NewCertPool()
	untrustedRoots.AppendCertsFromPEM(buf)

	/*	trustedRoots := x509.NewCertPool()
	for _, c := range roots.certs {
		if !untrustedRoots.contains(c) {
			trustedRoots.AddCert(c)
		}
	}
	return trustedRoots, nil*/
	return nil, nil
}
